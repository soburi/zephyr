# M5Stack CoreS3 display SPI configuration comparison

## Zephyr board support (`boards/m5stack/m5stack_cores3/m5stack_cores3_procpu_common.dtsi`)
- The on-board ILI9342C panel is exposed through the `mipi_dbi` shim on `spi2`, using chip-select 0 and GPIO35 for the D/C signal; `cmd-data-tristate` forces the pad back to an input between transfers so the shared TF-card on chip-select 1 can still drive MISO, while reset remains on the AW9523 expander.【F:boards/m5stack/m5stack_cores3/m5stack_cores3_procpu_common.dtsi†L20-L64】【F:boards/m5stack/m5stack_cores3/m5stack_cores3_procpu_common.dtsi†L228-L264】
- `spi2` now advertises half-duplex 3-wire mode via the `half-duplex;` and `sio;` flags alongside `line-idle-low;`, keeping the 40 MHz clock and GPIO routing through the matrix (SCLK = GPIO36, MOSI = GPIO37, MISO/D/C = GPIO35).【F:boards/m5stack/m5stack_cores3/m5stack_cores3_procpu_common.dtsi†L228-L247】【F:boards/m5stack/m5stack_cores3/m5stack_cores3-pinctrl.dtsi†L33-L48】
- The ESP32-S3 master driver now derives `hal_dev->half_duplex` from `SPI_HALF_DUPLEX`, so `spi_ll_set_half_duplex` clears `USER.doutdin` while `spi_ll_set_sio_mode` honours the three-wire flag; the existing timing calculator still resolves the divider from the 80 MHz APB clock to `SPI_CLOCK_REG = 0x00001001`.【F:drivers/spi/spi_esp32_spim.c†L406-L435】【F:modules/hal/espressif/components/hal/spi_hal_iram.c†L31-L69】【F:modules/hal/espressif/components/hal/esp32s3/include/hal/spi_ll.h†L564-L591】【F:modules/hal/espressif/components/hal/esp32s3/include/hal/spi_ll.h†L702-L735】
- The `mipi_dbi` SPI backend configures GPIO35 as an input at boot, switches it to an output only while asserting the command/data level, then returns it to high impedance when the transfer finishes—mirroring the CoreS3 wiring where D/C and MISO share the same trace.【F:drivers/mipi_dbi/mipi_dbi_spi.c†L74-L121】【F:drivers/mipi_dbi/mipi_dbi_spi.c†L190-L319】【F:drivers/mipi_dbi/mipi_dbi_spi.c†L520-L573】【F:drivers/mipi_dbi/mipi_dbi_spi.c†L608-L715】

### Expected SPI2 register snapshot after `spi_hal_setup_device`

| Register | Value | Notes |
| --- | --- | --- |
| `SPI_CLOCK_REG(2)` | `0x00001001` | 80 MHz APB source, 40 MHz target -> `clkcnt_n = 1`, `clkcnt_l = 1`, `clkdiv_pre = 0`.【F:modules/hal/espressif/components/hal/esp32s3/include/hal/spi_ll.h†L702-L735】 |
| `SPI_USER_REG(2)` | `0x08020000` | Half-duplex (`doutdin = 0`), SIO enabled (`sio = 1`), write phase active (`usr_mosi = 1`).【F:modules/hal/espressif/components/hal/esp32s3/include/hal/spi_ll.h†L564-L591】【F:modules/hal/espressif/components/hal/spi_hal_iram.c†L181-L205】【F:modules/hal/espressif/components/soc/esp32s3/include/soc/spi_struct.h†L72-L140】 |
| `SPI_USER1_REG(2)` | `0x00000000` | CS setup/hold and dummy/address stages remain disabled until a transfer configures them.【F:modules/hal/espressif/components/hal/spi_hal_iram.c†L31-L108】 |
| `SPI_USER2_REG(2)` | `0x00000000` | Command phase populated by each transaction as needed.【F:modules/hal/espressif/components/hal/spi_hal_iram.c†L70-L108】 |
| `SPI_CTRL_REG(2)` | `0x00000000` | `line-idle-low` keeps MOSI/MISO idle low (`d_pol = q_pol = 0`).【F:drivers/spi/spi_esp32_spim.c†L471-L492】【F:modules/hal/espressif/components/soc/esp32s3/include/soc/spi_struct.h†L40-L80】 |
| `SPI_CMD_REG(2)` | `0x00000000` | No command pending immediately after device setup.【F:modules/hal/espressif/components/hal/spi_hal_iram.c†L31-L69】 |
| `SPI_MS_DLEN_REG(2)` | `0x00000000` | Bit length loaded per transaction, zero when idle.【F:modules/hal/espressif/components/soc/esp32s3/include/soc/spi_struct.h†L120-L140】 |
| `SPI_DMA_CONF_REG(2)` | `0x00180000` | DMA helpers armed; channels remain idle until a transfer starts.【F:modules/hal/espressif/components/hal/spi_hal.c†L45-L76】【F:modules/hal/espressif/components/soc/esp32s3/include/soc/spi_struct.h†L200-L240】 |

## M5Unified runtime SPI programming (`M5GFX`)
- `Panel_M5StackCoreS3` drives the LCD via GPIO3 for chip-select and reconfigures GPIO35 between output (D/C) and input (MISO) every time CS toggles, matching the board’s shared trace.【F:doc/m5gfx_coreS3_spi.cpp†L9-L26】
- The CoreS3 autodetect path on `spi2` binds MOSI = GPIO37, SCLK = GPIO36, MISO/D/C = GPIO35, explicitly sets `bus_cfg.spi_3wire = true`, and programs 40 MHz write / 16 MHz read clocks before instantiating the panel.【F:doc/m5gfx_coreS3_spi.cpp†L29-L43】
- `Bus_SPI::beginTransaction` writes the divider computed by `FreqToClockDiv` and loads `_user_reg = SPI_USR_MOSI` (`0x08000000`), while `SPI_PIN_REG` disables the unused hardware chip-selects because the panel uses a GPIO CS.【F:doc/m5gfx_coreS3_spi.cpp†L46-L74】
- `Bus_SPI::beginRead` swaps `SPI_USER` to `SPI_USR_MISO | SPI_SIO` (`0x10020000`) so reads also run over the three-wire bus after the D/C line is released.【F:doc/m5gfx_coreS3_spi.cpp†L76-L86】
- Because the read path toggles `SPI_SIO` rather than leaving the line unused, M5Unified programmes the controller for true three-wire half-duplex operation—the MISO pad actively shares GPIO35 with the D/C latch instead of behaving like a four-wire bus with an unconnected data input.【F:doc/m5gfx_coreS3_spi.cpp†L9-L86】

## M5Unified defaults (`src/M5Unified.cpp`)
- The library builds pin maps per board; for CoreS3 it routes the SPI clock/data lines to GPIO36/37/35 and SD CS to GPIO4—the same bus that Zephyr binds to the display/SD pair—while other tables describe how the M-Bus headers and accessory ports share those pins.【F:doc/m5unified_M5Unified.cpp†L54-L143】【F:doc/m5unified_M5Unified.cpp†L200-L246】
- Board-specific helpers reuse these tables at runtime, allowing the firmware to remap connectors or peripherals (e.g. Module audio or Atomic accessories) before the display driver in M5GFX claims the bus.【F:doc/m5unified_M5Unified.cpp†L247-L318】【F:doc/m5unified_M5Unified.cpp†L1264-L1411】

## Notable differences
1. **Static vs dynamic wiring** – Zephyr now mirrors the CoreS3 hardware by sharing GPIO35 between D/C and MISO through `cmd-data-tristate` and SIO mode, while M5Unified still performs runtime remapping to accommodate accessories on the M-Bus connectors.【F:boards/m5stack/m5stack_cores3/m5stack_cores3_procpu_common.dtsi†L20-L64】【F:doc/m5unified_M5Unified.cpp†L54-L143】
2. **Register sequencing** – Both stacks drive the bus from an 80 MHz APB source, yielding `SPI_CLOCK_REG = 0x00001001` and switching `SPI_USER` between `0x0802_0000` (writes) and `0x1002_0000` (reads) for the three-wire data phases; Zephyr now accomplishes this through DT/HAL configuration, whereas M5Unified programs the registers directly in `Bus_SPI` as it probes the panel.【F:modules/hal/espressif/components/hal/esp32s3/include/hal/spi_ll.h†L702-L735】【F:modules/hal/espressif/components/hal/spi_hal_iram.c†L181-L205】【F:doc/m5gfx_coreS3_spi.cpp†L46-L86】

## Register values versus transaction sequencing

Simply matching the register snapshot is not sufficient to keep the CoreS3 panel alive. Two pieces of runtime sequencing must also track what M5Unified does:

* **HAL half-duplex bookkeeping.** The ESP32 master driver has to propagate `SPI_HALF_DUPLEX` so that the HAL clears `USER.doutdin`, enables SIO, and sizes the RX bit length before each transaction (`spi_hal_setup_device`/`spi_hal_setup_trans`). Without that handshake the hardware never switches between the write (`0x0802_0000`) and read (`0x1002_0000`) `SPI_USER` patterns even if the static register values are preloaded.【F:drivers/spi/spi_esp32_spim.c†L392-L449】【F:modules/hal/espressif/components/hal/spi_hal_iram.c†L31-L108】
* **Command/data GPIO choreography.** The MIPI-DBI shim mirrors the M5Unified sequence by packing the command bit into 9-bit writes, then tri-stating GPIO35 before issuing the read phase so the panel can drive the shared trace. After every transfer the driver reverts the GPIO to an input, meaning subsequent reads begin with the line already released. Leaving the GPIO as an output stalls the bus even if the register block is correct.【F:drivers/mipi_dbi/mipi_dbi_spi.c†L63-L144】【F:drivers/mipi_dbi/mipi_dbi_spi.c†L368-L433】【F:drivers/mipi_dbi/mipi_dbi_spi.c†L600-L663】 なお `mipi_dbi_spi_configure_te()` はティアリングエフェクト端子を入力に設定するだけで、D/C 線（GPIO35）の入出力を切り替えるトライステート制御とは別物である点に注意してください。【F:drivers/mipi_dbi/mipi_dbi_spi.c†L661-L715】

Consequently, Zephyr needs both the register configuration and the transaction-level choreography; changing register constants alone does not reproduce the working M5Unified behaviour.

## If the SD card slot is ignored
Even when the TF/SD socket on CS1 is not supported, the CoreS3 panel still depends on two hardware behaviours that mainline Zephyr lacked before these changes:

* **Half-duplex SIO signalling remains mandatory.** GPIO35 physically multiplexes the D/C latch with the controller’s MISO pad, so the peripheral must be configured for 3-wire operation to match the register programming that M5Unified issues through `spi_hal_setup_device` (`USER.doutdin = 0`, `USER.sio = 1`). This still requires both the devicetree flags (`half-duplex;` and `sio;`) and the ESP32 master driver forwarding `SPI_HALF_DUPLEX` into the HAL state so `spi_ll_set_half_duplex()` and `spi_ll_set_sio_mode()` run.【F:boards/m5stack/m5stack_cores3/m5stack_cores3_procpu_common.dtsi†L228-L247】【F:drivers/spi/spi_esp32_spim.c†L406-L435】【F:modules/hal/espressif/components/hal/spi_hal_iram.c†L181-L205】【F:doc/m5gfx_coreS3_spi.cpp†L29-L86】
* **The D/C GPIO must still be tri-stated for readback.** CoreS3 ties the panel’s `SDO` pin and the command/data latch to the same copper run on GPIO35; when a write starts, firmware drives the desired D/C level, then releases the pad so the panel can push its status or pixel data back during the read phase. M5Unified achieves this by converting GPIO35 to an input each time chip-select goes high, before reasserting it for the next command.【F:doc/m5gfx_coreS3_spi.cpp†L9-L43】 Without a matching `cmd-data-tristate` path in Zephyr’s MIPI-DBI shim, returning to input mode never happens, so the LCD’s `SDO` output is electrically blocked and read transfers stall even if no SD device is present.【F:drivers/mipi_dbi/mipi_dbi_spi.c†L52-L121】【F:drivers/mipi_dbi/mipi_dbi_spi.c†L520-L573】 `mipi_dbi_spi_configure_te()` が扱うティアリングエフェクト GPIO は常に入力として確保されており、ここで D/C 線を三態化しているわけではない。

## Why the tri-state choreography is required
The CoreS3 display wiring collapses the usual four SPI wires (MOSI, MISO, D/C, CS) into three physical signals by double-purposing GPIO35. During command writes the host drives MOSI while holding GPIO35 low for command mode or high for data mode; once the payload is complete the same GPIO must become high impedance so the panel can source its `SDO` signal on the next read. Leaving the pad configured as a push-pull output—even when no SD card is connected—prevents the LCD from ever seizing the line, so panel initialisation fails as soon as the driver tries to poll `TE`, `STATUS`, or read pixel data.【F:doc/m5gfx_coreS3_spi.cpp†L9-L86】【F:drivers/mipi_dbi/mipi_dbi_spi.c†L52-L121】【F:drivers/mipi_dbi/mipi_dbi_spi.c†L520-L573】 Zephyr therefore mirrors M5Unified’s sequencing: drive the D/C level only while CS is asserted, revert to input immediately afterwards, and re-drive it just before the next transfer.

Consequently, dropping SD card support only avoids the pin-sharing conflict on CS1—the LCD-specific half-duplex sequencing and D/C direction management remain prerequisites for reproducing the proven M5Unified register state.
